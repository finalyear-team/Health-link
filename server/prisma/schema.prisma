// // This is your Prisma schema file,
// // learn more about it in the docs: https://pris.ly/d/prisma-schema

// // Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// // Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

enum PaymentStatus {
  pending
  completed
}

enum UserType {
  doctor
  patient
  admin
  moderator
  organization
}

enum UserStatus {
  active
  inactive
  suspended
  blocked
  deleted
}

enum ItemType {
  post
  forum
}

enum AttachmentType {
  image
  video
  file
}

enum GroupChatRole {
  member
  admin
  owner
}

enum MessageType {
  one_to_one
  group
}

enum Gender {
  Male
  Female
}

enum AppointmentType {
  initialConsultation
  followup
  emergency
}

enum ScheduleStatus {
  available
  unavailable
}

enum ScheduleType {
  emergency
  personal
  normal
}

enum AppointmentStatus {
  pending
  booked
  completed
  cancelled
}

enum ChannelType {
  dm
  supportGroup
}

enum Role {
  member
  owner
  admin
  guest
  banned
}

enum LikeItemType {
  forumAnswer
  post
}
enum LikeType {
  like
  dislike
}

enum CommentableType {
  forumAnswer
  post
}

enum FeedbackType {
  generalFeedback
  productReview
  serviceReview
}

enum Weekday {
  monday
  tuesday
  wednesday
  thursday
  friday
  saturday
  sunday
}

model Users {
  UserID                String              @id
  Username              String              @unique
  FirstName             String?
  LastName              String?
  Email                 String              @unique
  DateOfBirth           DateTime?
  Gender                Gender?
  Bio                   String?             @db.LongText
  PhoneNumber           String?
  Address               String?
  ProfilePicture        String?
  Role                  UserType
  Status                UserStatus
  Verified              Boolean             @default(false)
  CreatedAt             DateTime            @default(now())
  UpdatedAt             DateTime            @updatedAt
  LastLogin             DateTime?
  MedicalRecord         MedicalRecord[]
  DoctorDetails         DoctorDetails?
  Reviews               DoctorReviews[]     @relation("patient_review")
  Appointments          Appointments[]      @relation("patient_appointment")
  AppointmentsCancelled Appointments[]      @relation("appointmentCancelledby")
  // Consultancy           Consultancy[]
  // PatientBooking        Booking[]           @relation("patientBooking")
  // BookingCancelled      Booking[]
  ForumPost             ForumPost[]
  ForumAnswer           ForumAnswer[]
  Comment               Comments[]
  Like                  Likes[]
  Views                 Views[]
  Prescription          Prescription[]      @relation("patient_prescription")
  Feedback              UserFeedback[]
  FeedbackReply         Reply[]
  ChatMessage           ChatMessage[]
  VideoChatMembers      MemberInVideoChat[]
  ChannelMembers        ChannelMember[]
  Schedules             DoctorSchedule[]
  DoctorReviews         DoctorReviews[]     @relation("doctor_review")
  DoctorAppointments    Appointments[]      @relation("doctor_appointment")
  // Consultancy           Consultancy[]
  // Booking               Booking[]
  Blog                  BlogPost[]
  Post                  Post[]
  DoctorPrescription    Prescription[]      @relation("doctor_prescription")
  Payment               Payment[]           @relation("patient_payment")
  DoctorPayment         Payment[]           @relation("doctor_payment")
  VideoChatRoom         VideoChatRoom[]
   FollowersFollowing    Followers[]         @relation("following")
  FollowersFollowers    Followers[]         @relation("followers")
  Notification           Notification[]

  @@index([Email], name: "email_index")
}

model MedicalRecord {
  RecordID     String   @id @default(uuid())
  UserID       String
  DateOfRecord DateTime @default(now())
  Diagnosis    Json?
  Medications  Json?
  Allergies    Json?
  Patient      Users    @relation(onDelete: Cascade, fields: [UserID], references: [UserID])
}

model DoctorDetails {
  DoctorID              String   @id
  Speciality            String?
  ConsultationFee       Decimal?
  EducationalBackground Json?
  LicenseNumber         String?
  ExperienceYears       Int?
  User                  Users    @relation(onDelete: Cascade, fields: [DoctorID], references: [UserID])

  @@index([Speciality], name: "Speciality_index")
}

model DoctorSchedule {
  ScheduleID   String         @id @default(uuid())
  DoctorID     String
  Date         DateTime?      @db.Date
  WeekDay      Weekday?     
  StartTime    DateTime       @db.Time
  EndTime      DateTime       @db.Time
  ScheduleType ScheduleType   @default(normal)
  Status       ScheduleStatus @default(available)
  Note         String?
  CreatedAt    DateTime       @default(now())
  UpdatedAt    DateTime       @updatedAt
  Appointments Appointments[]
  Doctor       Users          @relation(onDelete: Cascade, fields: [DoctorID], references: [UserID])
}

model Appointments {
  AppointmentID   String            @id @default(uuid())
  DoctorID        String
  PatientID       String
  ScheduleID      String 
  AppointmentDate DateTime        @db.Date
  AppointmentTime DateTime        @db.Time
  Duration        Int?
  Status          AppointmentStatus @default(pending)
  AppointmentType AppointmentType   @default(initialConsultation)
  Note            String?           @db.Text
  CreatedAt       DateTime          @default(now())
  UpdatedAt       DateTime          @updatedAt
  CancelledBy     String?           @unique
  CancelledReason String?
  VideoChatRoomID String
  Doctor          Users             @relation(onDelete: Cascade, "doctor_appointment", fields: [DoctorID], references: [UserID])
  Patient         Users             @relation(onDelete: Cascade, "patient_appointment", fields: [PatientID], references: [UserID])
  Cancelled       Users?            @relation(onDelete: Cascade, "appointmentCancelledby", fields: [CancelledBy], references: [UserID])

  Schedule      DoctorSchedule @relation(onDelete: Cascade, fields: [ScheduleID], references: [ScheduleID])
  // Booking         Booking[]
  Payment       Payment?
  VideoChatRoom VideoChatRoom  @relation(onDelete: Cascade, fields: [VideoChatRoomID], references: [RoomID])

  @@index([Status], name: "status_index")
  @@index([DoctorID, PatientID], name: "doctor_patient_index")
}

// model Booking {
//   BookingID       String        @id @default(uuid())
//   CreatedAt       DateTime      @default(now())
//   UpdatedAt       DateTime      @updatedAt
//   Status          String        @default("Pending")
//   PatientID       String
//   DoctorID        String
//   AppointmentID   String        @unique
//   ReminderSent    Boolean       @default(false)
//   ReminderDate    DateTime?
//   CancelledBy     String?       @unique
//   CancelledReason String?
//   Doctor          DoctorDetails @relation(onDelete: Cascade,fields: [DoctorID], references: [DoctorID])
//   Patient         Users         @relation(onDelete: Cascade,"patientBooking", fields: [PatientID], references: [UserID])
//   Appointment     Appointments? @relation(onDelete: Cascade,fields: [AppointmentID], references: [AppointmentID])
//   Cancelled       Users?        @relation(onDelete: Cascade,fields: [CancelledBy], references: [UserID])

//   @@index([DoctorID], name: "patient_doctor_index")
// }

// model Consultancy {
//   ConsultancyID   String            @id @default(uuid())
//   DoctorID        String
//   PatientID       String
//   Appointment     String
//   ConsultancyDate DateTime   
//   ConsultancyTime DateTime   @db.Time()
//   Duration        Int
//   Status          AppointmentStatus
//   AppointmentType AppointmentType
//   Note           String?           @db.LongText
//   CreatedAt       DateTime          @default(now())
//   UpdatedAt       DateTime          @updatedAt
//   CancelledBy     String?
//   CancelledReason String?
//   Doctor          DoctorDetails     @relation(onDelete: Cascade,fields: [DoctorID], references: [DoctorID])
//   Patient         Users             @relation(onDelete: Cascade,fields: [PatientID], references: [UserID])
//   Payment         Payment?

//   @@index([Status], name: "consultancy_status_index")
// }

model VideoChatRoom {
  RoomID        String              @id
  Name          String
  HostID        String
  HostAuthToken String              @db.LongText
  CreatedAt     DateTime            @default(now())
  UpdatedAt     DateTime            @updatedAt
  Host          Users               @relation(onDelete: Cascade, fields: [HostID], references: [UserID])
  Appointment   Appointments[]
  Members       MemberInVideoChat[]
}

model MemberInVideoChat {
  MemberID          String        @id @unique
  VideoChatRoomID String
  MemberAuthToken String        @db.LongText
  User            Users         @relation(onDelete: Cascade, fields: [MemberID], references: [UserID])
  VideoChatRoom   VideoChatRoom @relation(onDelete: Cascade, fields: [VideoChatRoomID], references: [RoomID])
}

// model that stores both dms and group chats it also stores PeerSupport group informations as channel
model ChatChannel {
  ChannelID   String          @id
  ChannelName String
  Image       String?
  Description String?         @db.Text
  Disease     String?
  ChannelType ChannelType
  CreatedAt   DateTime        @default(now())
  UpdatedAt   DateTime        @updatedAt
  ChatMessage ChatMessage[]
  Members     ChannelMember[]
}

model ChatMessage {
  ChatID    String      @id
  Content   String
  SenderID  String
  MediaUrl  String?
  SentAt    DateTime    @default(now())
  IsSeen    Boolean     @default(false)
  ChannelID String
  Sender    Users       @relation(onDelete: Cascade, fields: [SenderID], references: [UserID])
  Channel   ChatChannel @relation(onDelete: Cascade, fields: [ChannelID], references: [ChannelID])
}

model ChannelMember {
  UserID           String      @id
  ChannelID        String
  AuthToken        String      @db.LongText
  Role             Role?        @default(member)
  JoinedAt         DateTime?   @default(now())
  CreatedAt        DateTime?   @default(now())
  UpdatedAt        DateTime?   @updatedAt
  User             Users       @relation(onDelete: Cascade, fields: [UserID], references: [UserID])
  PeerSupportGroup ChatChannel @relation(onDelete: Cascade, fields: [ChannelID], references: [ChannelID])
}

model Payment {
  PaymentID     String        @id @default(uuid())
  DoctorID      String
  PatientID     String
  Amount        Float
  PaymentDate   DateTime      @default(now())
  PaymentMethod String?
  Status        String
  AppointmentID String?       @unique
  // ConsultancyID String?       @unique
  PaymentStatus PaymentStatus
  Patient       Users         @relation(onDelete: Cascade, "patient_payment", fields: [PatientID], references: [UserID])
  Doctor        Users         @relation(onDelete: Cascade, "doctor_payment", fields: [DoctorID], references: [UserID])
  Appointment   Appointments? @relation(onDelete: Cascade, fields: [AppointmentID], references: [AppointmentID])
  // Consultancy   Consultancy?  @relation(onDelete: Cascade,fields: [ConsultancyID], references: [ConsultancyID])

  @@index([DoctorID], name: "doctor_payment_index")
}

model DoctorReviews {
  ReviewID   String   @id @default(uuid())
  DoctorID   String
  ReviewerID String
  Rating     Int?
  ReviewText String?  @db.LongText
  ReviewDate DateTime @default(now())
  Doctor     Users    @relation(onDelete: Cascade, "doctor_review", fields: [DoctorID], references: [UserID])
  Reviewer   Users    @relation(onDelete: Cascade, "patient_review", fields: [ReviewerID], references: [UserID])

  @@index([DoctorID], name: "doctor_review_index")
}

model BlogPost {
  BlogID      String   @id @default(uuid())
  Title       String
  Content     String   @db.LongText
  CreatedAt   DateTime @default(now())
  UpdatedAt   DateTime @updatedAt
  IsPublished Boolean  @default(false)
  DoctorID    String
  Doctor      Users    @relation(onDelete: Cascade, fields: [DoctorID], references: [UserID])
  View        Views[]
}

model ForumPost {
  ForumPostID String        @id @default(uuid())
  Content     String        @db.LongText
  CreatedAt   DateTime      @default(now())
  UpdatedAt   DateTime      @updatedAt
  UserID      String
  User        Users         @relation(onDelete: Cascade, fields: [UserID], references: [UserID])
  Answers     ForumAnswer[]
}

model ForumAnswer {
  ForumAnswerID String     @id @default(uuid())
  Content       String
  CreatedAt     DateTime   @default(now())
  UpdatedAt     DateTime   @updatedAt
  ForumPostID   String
  UserID        String
  ForumPost     ForumPost  @relation(onDelete: Cascade, fields: [ForumPostID], references: [ForumPostID])
  User          Users      @relation(onDelete: Cascade, fields: [UserID], references: [UserID])
  Comment       Comments[]
  Like          Likes[]
}

model Post {
  PostID    String     @id @default(uuid())
  Content   String
  MediaUrl  String?
  CreatedAt DateTime   @default(now())
  UpdatedAt DateTime   @updatedAt
  DoctorID  String
  Doctor    Users      @relation(onDelete: Cascade, fields: [DoctorID], references: [UserID])
  View      Views[]
  Comment   Comments[]
  Like      Likes[]
}

model Comments {
  CommentID       String          @id @default(uuid())
  Content         String
  CreatedAt       DateTime        @default(now())
  UpdatedAt       DateTime        @updatedAt
  UserID          String
  ItemID          String
  ParentCommentID String?
  User            Users           @relation(onDelete: Cascade, fields: [UserID], references: [UserID])
  ParentComment   Comments?       @relation(onDelete: Cascade, "ParentComment", fields: [ParentCommentID], references: [CommentID])
  Replies         Comments[]      @relation("ParentComment")
  Like            Likes[]
  ItemType        CommentableType
  Post            Post?           @relation(onDelete: Cascade, fields: [ItemID], references: [PostID])
  ForumAnswer     ForumAnswer?    @relation(onDelete: Cascade, fields: [ItemID], references: [ForumAnswerID], map: "forumanswer_fkey")
}

model Likes {
  LikeID      String       @id @default(uuid())
  UserID      String
  ItemID      String
  ItemType    LikeItemType
  LikeType    LikeType     @default(like)
  CreatedAt   DateTime     @default(now())
  User        Users        @relation(onDelete: Cascade, fields: [UserID], references: [UserID])
  Post        Post?        @relation(onDelete: Cascade, fields: [ItemID], references: [PostID])
  ForumAnswer ForumAnswer? @relation(onDelete: Cascade, fields: [ItemID], references: [ForumAnswerID], map: "forum_answer_fkey")
  Comment     Comments?    @relation(onDelete: Cascade, fields: [ItemID], references: [CommentID], map: "commet_fkey")
}

model Views {
  ViewID    String          @id @default(uuid())
  UserID    String?
  ItemID    String
  ItemType  CommentableType
  CreatedAt DateTime        @default(now())
  User      Users?          @relation(onDelete: Cascade, fields: [UserID], references: [UserID])
  BlogPost  BlogPost?       @relation(onDelete: Cascade, fields: [ItemID], references: [BlogID])
  Post      Post?           @relation(onDelete: Cascade, fields: [ItemID], references: [PostID], map: "post_view_fkey")
}

model FAQ {
  FAQID     String   @id @default(uuid())
  Question  String
  Answer    String
  Order     Int      @default(0)
  CreatedAt DateTime @default(now())
  UpdatedAt DateTime @updatedAt
}

model UserFeedback {
  FeedbackID String       @id @default(uuid())
  UserID     String
  Content    String
  CreatedAt  DateTime     @default(now())
  UpdatedAt  DateTime     @updatedAt
  Type       FeedbackType @default(generalFeedback)
  Rating     Int? // Optional, for reviews
  Review     String? // Optional, for reviews
  Replies    Reply[]
  User       Users        @relation(onDelete: Cascade, fields: [UserID], references: [UserID])
}

model Reply {
  ReplyID    String       @id @default(uuid())
  FeedbackID String
  Content    String
  CreatedAt  DateTime     @default(now())
  UpdatedAt  DateTime     @updatedAt
  UserID     String
  Feedback   UserFeedback @relation(onDelete: Cascade, fields: [FeedbackID], references: [FeedbackID])
  User       Users        @relation(onDelete: Cascade, fields: [UserID], references: [UserID])
}

model Prescription {
  PrescriptionID    String                   @id @default(uuid())
  DoctorID          String
  PatientID         String
  IssuedAt          DateTime                 @default(now())
  ValidUntil        DateTime?
  Note              String?
  Status            String?
  Doctor            Users                    @relation(onDelete: Cascade, "doctor_prescription", fields: [DoctorID], references: [UserID])
  Patient           Users                    @relation(onDelete: Cascade, "patient_prescription", fields: [PatientID], references: [UserID])
  PrescriptionItems PrescriptionItem[]
  Attachment        PrescriptionAttachment[]
}

model PrescriptionItem {
  PrescriptionItemID String       @id @default(uuid())
  PrescriptionID     String
  MedicationName     String
  Dosage             String
  Instructions       String?
  Quantity           Int?
  Frequency          String?
  Duration           String?
  Prescription       Prescription @relation(onDelete: Cascade, fields: [PrescriptionID], references: [PrescriptionID])
}

model PrescriptionAttachment {
  AttachmentID   String       @id @default(uuid())
  PrescriptionID String
  URL            String
  Filename       String
  Size           Int
  Caption        String?
  FileType       String
  Prescription   Prescription @relation(onDelete: Cascade, fields: [PrescriptionID], references: [PrescriptionID])
}

model Followers {
  FollowerID   String   @id
  Follower     Users    @relation("following", fields: [FollowerID], references: [UserID])
  FollowingID  String
  Following    Users    @relation("followers", fields: [FollowingID], references: [UserID])
  CreatedAt    DateTime @default(now())

  @@index([FollowerID, FollowingID], name: "follower_following_unique")
}

model Notification{
  NotificationID String @id @default(uuid())
  UserID     String
  Message    String @db.Text()
  CreatedAt  DateTime  @default(now())
  UpdatedAt  DateTime  @updatedAt
  User       Users    @relation(fields: [UserID] ,references: [UserID])
}


